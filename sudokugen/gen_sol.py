"""
This file contains a backtracking
sudoku solver for generating fully
-populated puzzles.

Here is another implementation of
the DFS/backtracking solver:
http://norvig.com/sudoku.html
"""
from collections import defaultdict
from functools import wraps, lru_cache
import math
import multiprocessing as mp
import logging
import queue
import random
import sys
import time

import numpy as np

from .db import insert_solutions, insert_puzzles, get_conn
from .constants import BOARD_DIM, COMPLETE_ROW, DEBUG, BLOCK_ARRAY, EMPTY

logger = logging.getLogger(__name__)



def assert_sol_is_valid(sol):
    """
    Solutions and puzzles generated by
    backtracking are valid automatically
    from algorithm implementation for generating
    possible candidates for each cell. However,
    transformations should be checked explicitly.

    (It's also good to use this function to
     check that backtracking is implemented
     correctly in solution/puzzle generation)
    """
    for n in range(BOARD_DIM):
        colcheck = set(sol[:, n]) == COMPLETE_ROW
        rowcheck = set(sol[n, :]) == COMPLETE_ROW
        squarecheck = set(sol[BLOCK_ARRAY == n]) == COMPLETE_ROW
        if not (colcheck and rowcheck and squarecheck):
            return False
    return True


def assert_board_is_valid(board):
    """
    Check that the current board, which may not
    be a completed solution, is in a valid state
    e.g. 1 does not appear twice in column, etc.
    """
    if not np.all(np.logical_and(board >=0, board<=BOARD_DIM)):
        return False

    for k in range(BOARD_DIM):
        row, col = board[k, :], board[:, k]
        rowcheck = np.unique(row[row != 0]).size == np.sum(row != 0)
        colcheck = np.unique(col[col != 0]).size == np.sum(col != 0)
        squaremask = np.logical_and(BLOCK_ARRAY == k, board != 0)
        squarecheck = np.unique(board[squaremask]).size == np.sum(squaremask)
        if not (colcheck and rowcheck and squarecheck):
            return False
    return True


def is_filled(board):
    return np.count_nonzero(board) == BOARD_DIM**2


@lru_cache()
def squares():
    """
    Generates "groups" which is a dictionary
    grouping sudoku puzzle indices belonging
    to the same square. Also generates the
    reverse lookup "lookup" from index to group.
    """
    groups = defaultdict(set)
    lookup = defaultdict(int)
    for x_arr, y_arr in zip(*np.indices((9, 9))):
        for x, y in zip(x_arr, y_arr):
            groups[BLOCK_ARRAY[x, y]].add((x, y))
            lookup[(x, y)] = BLOCK_ARRAY[x, y]
    return groups, lookup


def choices_from_square(board, x, y):
    groups, lookup = squares()
    g = lookup[(x, y)]
    cells_in_g = groups[g]
    numbers_in_g = {board[a, b] for a, b in cells_in_g}
    return COMPLETE_ROW - numbers_in_g


class SudokuBaseException(Exception):
    pass


class InvalidBoard(SudokuBaseException):
    pass


class NoSolution(SudokuBaseException):
    pass


def candidates_dict(board):
    candidates = defaultdict(set)
    it = board.flat # C-style indexed iterator
    coords = it.coords
    for cell in it:
        if cell == EMPTY:
            candidates[coords] = construct_candidates(board, *coords)
        coords = it.coords
    return candidates


def construct_candidates(board, x, y):
    """
    Return a set of eligible candidates for the cell at (x, y).
    Raises NoSolution if x, y has no candidate, implying
    that the given board has no solution.
    """
    from_row = COMPLETE_ROW - set(board[x, :])
    from_col = COMPLETE_ROW - set(board[:, y])
    from_square = choices_from_square(board, x, y)
    candidates = from_row & from_col & from_square
    # if DEBUG:
    #     print("================")
    #     print(board)
    #     print("x: ", x)
    #     print("y: ", y)
    #     print("from rows:", from_row)
    #     print("from cols:", from_col)
    #     print("from block:", from_square)
    #     print("candidates:", candidates)
    if not candidates:
        raise NoSolution("Cell (%d, %d) has no candidate" % (x, y))
    return candidates


def get_unfilled_cell_rand(board):
    zero_indices = np.argwhere(board == 0)
    if len(zero_indices) > 0:
        cell_index = np.random.randint(len(zero_indices))
    else:
        raise IndexError("No unfilled cell remaining!")
    x, y = zero_indices[cell_index]
    return x, y


def get_shuffled_unfilled_cells(board):
    zero_indices = np.argwhere(board == 0)
    if len(zero_indices) > 0:
        np.random.shuffle(zero_indices)
    else:
        raise IndexError("No unfilled cell remaining!")
    return zero_indices


def propagate_constraint(board):
    """Fill out squares for which there is only
        one choice remaining after applying the
        previous guess"""
    while True:
        cont = False
        candidates = candidates_dict(board)
        for (x, y), cands in candidates.items():
            if len(cands) == 1:
                board[(x, y)] = cands.pop()
                cont = True
                break
        if not cont:
            break


def from_empty_board():
    """
    To produce a complete sudoku board from scratch:
        1. Fill in 20 cells randomly to create a baseline puzzle
        2. Attempt to create a solution from the baseline puzzle

    *According the Skiena, 17 is the fewest known number of positions
    in any sudoku that has a unique solution.

    The choice of randomly selecting 20 cells is to reduce
    the search space and hence the runtime of creating a complete
    sudoku board. Attempting to generate a solution from, say, an
    empty board directly can lead to very unpredictable runtimes,
    depending on the luck of the RNG.

    Note, there's no guarantee that a solution exists given the
    20 random choices, so the function could return None.
    """
    board = np.zeros((BOARD_DIM, BOARD_DIM,), dtype=int)
    guess_until = 20
    while np.count_nonzero(board) < guess_until:
        x, y = get_unfilled_cell_rand(board)
        candidates = construct_candidates(board, x, y)
        board[x, y] = random.choice(list(candidates))
    return backtrack_iter(board)


def measure(log):
    def inner(func):
        @wraps(func)
        def decorator(*args, **kwargs):
            start = time.perf_counter()
            ret = func(*args, **kwargs)
            end = time.perf_counter()
            log.info("%s: %.2f" % (func.__name__, end-start))
            return ret
        return decorator
    return inner


def backtrack_iter(board):
    """
    Implements DFS-style backtracking to obtain
    a solution to the given board.
    """
    if not assert_board_is_valid(board):
        raise InvalidBoard("Provided board violates Sudoku rules.")

    pruned = set() # keep track of pruned nodes
    stack = [board]
    while stack:
        board = stack.pop()

        if DEBUG:
            msg = "# filled: %d, stack size: %d, # pruned root nodes: %d\r"
            sys.stdout.write(msg % (
                np.count_nonzero(board), len(stack), len(pruned)))
            sys.stdout.flush()

        # exit when a solution is found
        # i.e. when all the cells have been filled
        if is_filled(board):
            return board

        # if we encounter cells with no possible values
        # when generating candidates, then the current
        # board has no solution. Do not go further down the path
        try:
            candidates = candidates_dict(board)
        except NoSolution:
            pruned.add(tuple(board.flat))
            continue

        # push the least-constrained options first
        # so that the most-constrained options are processed first
        by_constraint = sorted(
            candidates.items(), key=lambda item: len(item[1]), reverse=True)

        for coords, cands in by_constraint:
            for cand in cands:
                next_board = board.copy()
                next_board[coords] = cand
                if tuple(next_board.flat) not in pruned:
                    stack.append(next_board)

    # if the stack is exhausted, then there is,
    # in fact, no solution to the posed problem
    return


def board_in_solutions(board, solutions):
    for sol in solutions:
        if np.all(np.equal(board, sol)):
            return True
    return False


def solution_unique(board):
    """Like backtrack_iter, but its main purpose is to
        check for uniqueness of generated puzzles from
        solutions"""
    stack, solutions = [board], []
    while True:
        try:
            board = stack.pop()
        except IndexError:
            if len(solutions) == 1:
                return True
            return False
        if is_filled(board):
            if not board_in_solutions(board, solutions):
                solutions.append(board)
            if len(solutions) > 1:
                return False
            continue
        x, y = get_unfilled_cell_rand(board)
        if DEBUG:
            sys.stdout.write("# filled: %d, stack size %d\r" % (
                np.count_nonzero(board), len(stack)))
            sys.stdout.flush()

        candidates = construct_candidates(board, x, y)
        for candidate in candidates:
            copied = board.copy()
            copied[x, y] = candidate
            propagate_constraint(copied)
            stack.append(copied)


# def prefill_diagonals(board):
#     """
#     Fill the diagonal squares (groups 0, 4, 8)
#     first prior to backtracking to reduce the
#     problem space.
#     """
#     groups, __ = squares()
#     for n in (0, 4, 8):
#         arr = np.arange(1, 10)
#         np.random.shuffle(arr)
#         for (x, y), k in zip(groups[n], arr):
#             board[x, y] = k
#     return board


def create_puzzle_from_board(board):
    positions = np.arange(81)
    np.random.shuffle(positions)
    positions = list(positions)

    while True:
        if not positions:
            return board

        position = positions.pop()
        x = position % BOARD_DIM
        y = math.floor(position / BOARD_DIM)

        old_val = board[x, y]
        board[x, y] = 0
        if not solution_unique(board):
            board[x, y] = old_val


def starting_board():
    return np.zeros((BOARD_DIM, BOARD_DIM), dtype=int)


def create_solution(input_q, output_q):
    while True:
        board = input_q.get()
        try:
            board, ct = board
            output_q.put((backtrack_iter(board), ct))
            # print("\nCreated Solution {}".format(ct))
            input_q.task_done()
        except queue.Full:
            if DEBUG:
                sys.stdout.write("$$ puzzle_q is full!\r")
                sys.stdout.flush()


def create_puzzle(input_q, output_q):
    while True:
        sol = input_q.get()
        sol, ct = sol
        puzzle = sol.copy()
        try:
            output_q.put((create_puzzle_from_board(puzzle), sol, ct,))
            # print("\nCreated Puzzle {}".format(ct))
            input_q.task_done()
        except queue.Full:
            if DEBUG:
                sys.stdout.write("## db_q is full!\r")
                sys.stdout.flush()


def to_db(input_q, db_batch_size):
    conn = get_conn()
    conn.autocommit = True
    cursor = conn.cursor()
    results = []
    sentinel = True
    while True:
        if not input_q.empty():
            board_and_sol = input_q.get()
            results.append(board_and_sol)

        if not results and sentinel is None:
            break
        if len(results) >= db_batch_size or sentinel is None:
            puzzles, boards, cts = zip(*results)
            insert_solutions(boards, cursor)
            insert_puzzles(zip(puzzles, boards), cursor)
            print("Stored {} puzzles and {} sols to db".format(
                len(results), len(boards)))
            [input_q.task_done() for __ in range(len(results))]
            results = []


def main(n_jobs, queue_size=100):
    if n_jobs:
        db_batch_size = min(math.floor(queue_size/2), n_jobs)
    else:
        db_batch_size = math.floor(queue_size/2)
    sol_q = mp.JoinableQueue(maxsize=queue_size)
    puzzle_q = mp.JoinableQueue(maxsize=queue_size)
    db_q = mp.JoinableQueue(maxsize=db_batch_size)

    create_ps, puzzle_ps = [], []
    for __ in range(3):
        create_p = mp.Process(target=create_solution, args=(sol_q, puzzle_q,))
        create_p.daemon = True
        create_p.start()

    for __ in range(9):
        create_ps.append(create_p)
        puzzle_p = mp.Process(target=create_puzzle, args=(puzzle_q, db_q,))
        puzzle_p.daemon = True
        puzzle_p.start()

    puzzle_ps.append(puzzle_p)
    db_p = mp.Process(target=to_db, args=(db_q, db_batch_size,))
    db_p.daemon = True
    db_p.start()

    enqueued = 0
    while True:
        if n_jobs is not None and enqueued >= n_jobs:
            break

        if not sol_q.full():
            sol_q.put((starting_board(), enqueued,))
            enqueued += 1
            print("== {} job(s) enqueued".format(enqueued))
        else:
            if DEBUG:
                sys.stdout.write("== sol_q is full!\r")
                sys.stdout.flush()
    sol_q.join()
    print("Solution process shutdown.")
    puzzle_q.join()
    print("Puzzle process shutdown.")
    db_q.join()
    print("Finished.")
